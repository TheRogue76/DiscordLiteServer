// DO NOT EDIT.
// swift-format-ignore-file
// swiftlint:disable all
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: discord/channel/v1/channel.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// ChannelType represents the type of Discord channel
public enum Discord_Channel_V1_ChannelType: SwiftProtobuf.Enum, Swift.CaseIterable {
  public typealias RawValue = Int
  case guildText // = 0
  case dm // = 1
  case guildVoice // = 2
  case groupDm // = 3
  case guildCategory // = 4
  case guildAnnouncement // = 5
  case announcementThread // = 10
  case guildPublicThread // = 11
  case guildPrivateThread // = 12
  case guildStageVoice // = 13
  case guildDirectory // = 14
  case guildForum // = 15
  case guildMedia // = 16
  case UNRECOGNIZED(Int)

  public init() {
    self = .guildText
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .guildText
    case 1: self = .dm
    case 2: self = .guildVoice
    case 3: self = .groupDm
    case 4: self = .guildCategory
    case 5: self = .guildAnnouncement
    case 10: self = .announcementThread
    case 11: self = .guildPublicThread
    case 12: self = .guildPrivateThread
    case 13: self = .guildStageVoice
    case 14: self = .guildDirectory
    case 15: self = .guildForum
    case 16: self = .guildMedia
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .guildText: return 0
    case .dm: return 1
    case .guildVoice: return 2
    case .groupDm: return 3
    case .guildCategory: return 4
    case .guildAnnouncement: return 5
    case .announcementThread: return 10
    case .guildPublicThread: return 11
    case .guildPrivateThread: return 12
    case .guildStageVoice: return 13
    case .guildDirectory: return 14
    case .guildForum: return 15
    case .guildMedia: return 16
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [Discord_Channel_V1_ChannelType] = [
    .guildText,
    .dm,
    .guildVoice,
    .groupDm,
    .guildCategory,
    .guildAnnouncement,
    .announcementThread,
    .guildPublicThread,
    .guildPrivateThread,
    .guildStageVoice,
    .guildDirectory,
    .guildForum,
    .guildMedia,
  ]

}

/// GetGuildsRequest requests the list of guilds for the authenticated user
public struct Discord_Channel_V1_GetGuildsRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Auth session ID from InitAuth
  public var sessionID: String = String()

  /// If true, bypass cache and fetch from Discord API
  public var forceRefresh: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// GetGuildsResponse contains the list of guilds
public struct Discord_Channel_V1_GetGuildsResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var guilds: [Discord_Channel_V1_Guild] = []

  /// True if data was served from cache
  public var fromCache: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// GetChannelsRequest requests the list of channels for a guild
public struct Discord_Channel_V1_GetChannelsRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Auth session ID
  public var sessionID: String = String()

  /// Discord guild ID
  public var guildID: String = String()

  /// If true, bypass cache and fetch from Discord API
  public var forceRefresh: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// GetChannelsResponse contains the list of channels
public struct Discord_Channel_V1_GetChannelsResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var channels: [Discord_Channel_V1_Channel] = []

  /// True if data was served from cache
  public var fromCache: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Guild represents a Discord guild (server)
public struct Discord_Channel_V1_Guild: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var discordGuildID: String = String()

  public var name: String = String()

  public var icon: String = String()

  public var owner: Bool = false

  public var permissions: Int64 = 0

  public var features: [String] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Channel represents a Discord channel
public struct Discord_Channel_V1_Channel: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var discordChannelID: String = String()

  public var guildID: String = String()

  public var name: String = String()

  public var type: Discord_Channel_V1_ChannelType = .guildText

  public var position: Int32 = 0

  public var parentID: String = String()

  public var topic: String = String()

  public var nsfw: Bool = false

  public var lastMessageID: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "discord.channel.v1"

extension Discord_Channel_V1_ChannelType: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\0CHANNEL_TYPE_GUILD_TEXT\0\u{1}CHANNEL_TYPE_DM\0\u{1}CHANNEL_TYPE_GUILD_VOICE\0\u{1}CHANNEL_TYPE_GROUP_DM\0\u{1}CHANNEL_TYPE_GUILD_CATEGORY\0\u{1}CHANNEL_TYPE_GUILD_ANNOUNCEMENT\0\u{2}\u{5}CHANNEL_TYPE_ANNOUNCEMENT_THREAD\0\u{1}CHANNEL_TYPE_GUILD_PUBLIC_THREAD\0\u{1}CHANNEL_TYPE_GUILD_PRIVATE_THREAD\0\u{1}CHANNEL_TYPE_GUILD_STAGE_VOICE\0\u{1}CHANNEL_TYPE_GUILD_DIRECTORY\0\u{1}CHANNEL_TYPE_GUILD_FORUM\0\u{1}CHANNEL_TYPE_GUILD_MEDIA\0")
}

extension Discord_Channel_V1_GetGuildsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetGuildsRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}session_id\0\u{3}force_refresh\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.sessionID) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.forceRefresh) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.sessionID.isEmpty {
      try visitor.visitSingularStringField(value: self.sessionID, fieldNumber: 1)
    }
    if self.forceRefresh != false {
      try visitor.visitSingularBoolField(value: self.forceRefresh, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Discord_Channel_V1_GetGuildsRequest, rhs: Discord_Channel_V1_GetGuildsRequest) -> Bool {
    if lhs.sessionID != rhs.sessionID {return false}
    if lhs.forceRefresh != rhs.forceRefresh {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Discord_Channel_V1_GetGuildsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetGuildsResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}guilds\0\u{3}from_cache\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.guilds) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.fromCache) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.guilds.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.guilds, fieldNumber: 1)
    }
    if self.fromCache != false {
      try visitor.visitSingularBoolField(value: self.fromCache, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Discord_Channel_V1_GetGuildsResponse, rhs: Discord_Channel_V1_GetGuildsResponse) -> Bool {
    if lhs.guilds != rhs.guilds {return false}
    if lhs.fromCache != rhs.fromCache {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Discord_Channel_V1_GetChannelsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetChannelsRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}session_id\0\u{3}guild_id\0\u{3}force_refresh\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.sessionID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.guildID) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.forceRefresh) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.sessionID.isEmpty {
      try visitor.visitSingularStringField(value: self.sessionID, fieldNumber: 1)
    }
    if !self.guildID.isEmpty {
      try visitor.visitSingularStringField(value: self.guildID, fieldNumber: 2)
    }
    if self.forceRefresh != false {
      try visitor.visitSingularBoolField(value: self.forceRefresh, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Discord_Channel_V1_GetChannelsRequest, rhs: Discord_Channel_V1_GetChannelsRequest) -> Bool {
    if lhs.sessionID != rhs.sessionID {return false}
    if lhs.guildID != rhs.guildID {return false}
    if lhs.forceRefresh != rhs.forceRefresh {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Discord_Channel_V1_GetChannelsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetChannelsResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}channels\0\u{3}from_cache\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.channels) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.fromCache) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.channels.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.channels, fieldNumber: 1)
    }
    if self.fromCache != false {
      try visitor.visitSingularBoolField(value: self.fromCache, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Discord_Channel_V1_GetChannelsResponse, rhs: Discord_Channel_V1_GetChannelsResponse) -> Bool {
    if lhs.channels != rhs.channels {return false}
    if lhs.fromCache != rhs.fromCache {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Discord_Channel_V1_Guild: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Guild"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}discord_guild_id\0\u{1}name\0\u{1}icon\0\u{1}owner\0\u{1}permissions\0\u{1}features\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.discordGuildID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.icon) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self.owner) }()
      case 5: try { try decoder.decodeSingularInt64Field(value: &self.permissions) }()
      case 6: try { try decoder.decodeRepeatedStringField(value: &self.features) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.discordGuildID.isEmpty {
      try visitor.visitSingularStringField(value: self.discordGuildID, fieldNumber: 1)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 2)
    }
    if !self.icon.isEmpty {
      try visitor.visitSingularStringField(value: self.icon, fieldNumber: 3)
    }
    if self.owner != false {
      try visitor.visitSingularBoolField(value: self.owner, fieldNumber: 4)
    }
    if self.permissions != 0 {
      try visitor.visitSingularInt64Field(value: self.permissions, fieldNumber: 5)
    }
    if !self.features.isEmpty {
      try visitor.visitRepeatedStringField(value: self.features, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Discord_Channel_V1_Guild, rhs: Discord_Channel_V1_Guild) -> Bool {
    if lhs.discordGuildID != rhs.discordGuildID {return false}
    if lhs.name != rhs.name {return false}
    if lhs.icon != rhs.icon {return false}
    if lhs.owner != rhs.owner {return false}
    if lhs.permissions != rhs.permissions {return false}
    if lhs.features != rhs.features {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Discord_Channel_V1_Channel: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Channel"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}discord_channel_id\0\u{3}guild_id\0\u{1}name\0\u{1}type\0\u{1}position\0\u{3}parent_id\0\u{1}topic\0\u{1}nsfw\0\u{3}last_message_id\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.discordChannelID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.guildID) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 4: try { try decoder.decodeSingularEnumField(value: &self.type) }()
      case 5: try { try decoder.decodeSingularInt32Field(value: &self.position) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.parentID) }()
      case 7: try { try decoder.decodeSingularStringField(value: &self.topic) }()
      case 8: try { try decoder.decodeSingularBoolField(value: &self.nsfw) }()
      case 9: try { try decoder.decodeSingularStringField(value: &self.lastMessageID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.discordChannelID.isEmpty {
      try visitor.visitSingularStringField(value: self.discordChannelID, fieldNumber: 1)
    }
    if !self.guildID.isEmpty {
      try visitor.visitSingularStringField(value: self.guildID, fieldNumber: 2)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 3)
    }
    if self.type != .guildText {
      try visitor.visitSingularEnumField(value: self.type, fieldNumber: 4)
    }
    if self.position != 0 {
      try visitor.visitSingularInt32Field(value: self.position, fieldNumber: 5)
    }
    if !self.parentID.isEmpty {
      try visitor.visitSingularStringField(value: self.parentID, fieldNumber: 6)
    }
    if !self.topic.isEmpty {
      try visitor.visitSingularStringField(value: self.topic, fieldNumber: 7)
    }
    if self.nsfw != false {
      try visitor.visitSingularBoolField(value: self.nsfw, fieldNumber: 8)
    }
    if !self.lastMessageID.isEmpty {
      try visitor.visitSingularStringField(value: self.lastMessageID, fieldNumber: 9)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Discord_Channel_V1_Channel, rhs: Discord_Channel_V1_Channel) -> Bool {
    if lhs.discordChannelID != rhs.discordChannelID {return false}
    if lhs.guildID != rhs.guildID {return false}
    if lhs.name != rhs.name {return false}
    if lhs.type != rhs.type {return false}
    if lhs.position != rhs.position {return false}
    if lhs.parentID != rhs.parentID {return false}
    if lhs.topic != rhs.topic {return false}
    if lhs.nsfw != rhs.nsfw {return false}
    if lhs.lastMessageID != rhs.lastMessageID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
